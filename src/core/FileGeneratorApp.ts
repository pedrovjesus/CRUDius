import { IGenerationConfig } from "../interfaces/generationConfig";
import EjsTemplateRenderer from "../lib/EjsTemplateRenderer";
import path from "path";

interface ExtraData {
  entities: { name: string }[];
}

interface GeneratedFile {
  path: string;
  content: string;
}

export class FileGeneratorApp {
  private readonly renderer: EjsTemplateRenderer;

  constructor(private readonly templatesDir: string) {
    this.renderer = new EjsTemplateRenderer(templatesDir);
  }

  /**
   * Generates all files based on the list of settings provided.
   */
  public async generate(
    configs: IGenerationConfig[],
    extraData?: ExtraData
  ): Promise<GeneratedFile[]> {
    const generatedFiles: GeneratedFile[] = [];

    for (const config of configs) {
      const { entityName, properties, filesToGenerate } = config;

      for (const file of filesToGenerate) {
        const templateFile = file.templateName.endsWith(".ejs")
          ? file.templateName
          : `${file.templateName}.ejs`;

        const relativePath = path.join(
          file.outputPath || `src/controllers/${entityName}`,
          file.outputFileName || `${entityName}.controller.ts`
        );

        const data = {
          entityName,
          properties,
          ...(extraData || {}),
        };

        try {
          console.log(`üîß Generating: ${relativePath} from ${templateFile}...`);
          const content = await this.renderer.render(templateFile, data);
          generatedFiles.push({ path: relativePath, content });
        } catch (error: any) {
          console.error(`‚ùå Error generating ${relativePath}:`, error.message);
          throw error;
        }
      }
    }

    return generatedFiles;
  }

  /**
   * Generates all standard application files
   */
  public async generateDefaultFiles(): Promise<GeneratedFile[]> {
    const defaultFiles = [
      {
        templateName: "package-template.ejs",
        outputFileName: "package.json",
        outputPath: "",
        data: {
          name: "Project",
          version: "1.0.0",
          description: "Project generated by CRUDius",
          main: "src/app.ts",
          scripts: {
            start: "tsx src/app.ts",
            build: "tsc",
          },
          dependencies: {
            express: "^4.17.1",
          },
          devDependencies: {
            typescript: "^4.5.4",
            "@types/node": "^16.11.7",
            "@types/express": "^4.17.13",
            sqlite3: "^5.1.7",
            tsx: "^4.16.2",
          },
        },
      },
      {
        templateName: "server-template.ejs",
        outputFileName: "server.ts",
        outputPath: "src",
        data: {},
      },
      {
        templateName: "app-template.ejs",
        outputFileName: "app.ts",
        outputPath: "src",
        data: {},
      },
    ];

    const results: GeneratedFile[] = [];

    for (const file of defaultFiles) {
      const relativePath = path.join(file.outputPath, file.outputFileName);
      console.log(`Generating default file: ${relativePath}`);
      const content = await this.renderer.render(file.templateName, file.data);
      results.push({ path: relativePath, content });
    }

    return results;
  }

  /**
   * Generates controllers and services files
   */
  public async generateEntityFilesAutomatically(
    entities: { name: string }[]
  ): Promise<GeneratedFile[]> {
    const allFiles: GeneratedFile[] = [];

    for (const entity of entities) {
      const entityFiles = await this.generate([
        {
          entityName: entity.name,
          properties: [],
          filesToGenerate: [
            {
              templateName: "controller-template",
              outputFileName: `${entity.name}.controller.ts`,
              outputPath: `src/controllers/${entity.name}`,
            },
            {
              templateName: "service-template",
              outputFileName: `${entity.name}.service.ts`,
              outputPath: `src/services/${entity.name}`,
            },
          ],
        },
      ]);
      allFiles.push(...entityFiles);
    }

    return allFiles;
  }
}
